import typing
from ctypes import Structure, pointer, c_void_p, CDLL

_T = typing.TypeVar('_T')
_CObjectPtr = typing.Type[pointer[c_void_p]]


class TranslationUnitLoadError(Exception):
    pass


class TranslationUnitSaveError(Exception):
    ERROR_UNKNOWN: int
    ERROR_TRANSLATION_ERRORS: int
    ERROR_INVALID_TU: int

    def __init__(self, enumeration: int, message: str) -> None: ...


class SourceLocation(Structure):
    @staticmethod
    def from_position(tu: 'TranslationUnit', file: str, line: int, column: int) -> 'SourceLocation': ...
    @staticmethod
    def from_offset(tu: 'TranslationUnit', file: str, offset: int) -> 'SourceLocation': ...
    @property
    def file(self) -> str: ...
    @property
    def line(self) -> int: ...
    @property
    def column(self) -> int: ...
    @property
    def offset(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...


class SourceRange(Structure):
    @staticmethod
    def from_locations(start: typing.Union[int, 'SourceLocation'], end: typing.Union[int, 'SourceLocation']) -> 'SourceRange': ...
    @property
    def start(self) -> 'SourceLocation': ...
    @property
    def end(self) -> 'SourceLocation': ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __contains__(self, other: 'SourceLocation') -> bool: ...
    def __repr__(self) -> str: ...


class Diagnostic():
    Ignored: int
    Note: int
    Warning: int
    Error: int
    Fatal: int

    DisplaySourceLocation: int
    DisplayColumn: int
    DisplaySourceRanges: int
    DisplayOption: int
    DisplayCategoryId: int
    DisplayCategoryName: int

    def __del__(self) -> None: ...
    @property
    def severity(self) -> int: ...
    @property
    def location(self) -> 'SourceLocation': ...
    @property
    def spelling(self) -> str: ...
    @property
    def ranges(self) -> typing.Iterator['SourceRange']: ...
    @property
    def fixits(self) -> typing.Iterator['FixIt']: ...
    @property
    def children(self) -> typing.Iterator['Diagnostic']: ...
    @property
    def category_number(self) -> int: ...
    @property
    def category_name(self) -> str: ...
    @property
    def option(self) -> str: ...
    @property
    def disable_option(self) -> str: ...
    def format(self, options: typing.Optional[int] = ...) -> str: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class FixIt():
    def __init__(self, range: 'SourceRange', value: str) -> None: ...
    def __repr__(self) -> str: ...
    range: 'SourceRange'
    value: str


class TokenKind():
    def __init__(self, value: int, name: str) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def from_value(value: int) -> 'TokenKind': ...
    @staticmethod
    def register(value: int, name: str) -> None: ...

    {% for name in map(repr, cindex.TokenKind._value_map.values()) -%}
    {{name[name.rfind('.')+1:]}}: 'TokenKind'
    {% endfor %}

class BaseEnumeration():
    def __init__(self, value: int) -> None: ...
    def from_param(self) -> int: ...
    @property
    def name(self) -> str: ...
    @classmethod
    def from_id(cls: typing.Type[_T], id: int) -> _T: ...
    def __repr__(self) -> str: ...


class CursorKind(BaseEnumeration):
    @staticmethod
    def get_all_kinds() -> typing.List['CursorKind']: ...


    {% for name in dir(cindex.CursorKind) | startswith('is_') -%}
    def {{name}}(self) -> bool: ...
    {% endfor %}
    {% for kind in cindex.CursorKind.get_all_kinds() -%}
    {{str(kind)[11:]}}: 'CursorKind'
    {% endfor %}

class TemplateArgumentKind(BaseEnumeration):
    {% for name in map(str, cindex.TemplateArgumentKind._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'TemplateArgumentKind'
    {% endfor %}

class ExceptionSpecificationKind(BaseEnumeration):
    {% for name in map(str, cindex.ExceptionSpecificationKind._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'ExceptionSpecificationKind'
    {% endfor %}

class Cursor(Structure):
    @staticmethod
    def from_location(tu: 'TranslationUnit', location: 'SourceLocation') -> 'Cursor': ...

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

    {% for name in dir(cindex.Cursor) | startswith('is_') -%}
    def {{name}}(self) -> bool: ...
    {% endfor %}
    def get_definition(self) -> typing.Optional['Cursor']: ...
    def get_usr(self) -> str: ...
    def get_included_file(self) -> 'File': ...

    @property
    def kind(self) -> CursorKind: ...
    @property
    def spelling(self) -> str: ...
    @property
    def displayname(self) -> str: ...
    @property
    def mangled_name(self) -> str: ...
    @property
    def location(self) -> 'SourceLocation': ...
    @property
    def linkage(self) -> 'LinkageKind': ...
    @property
    def tls_kind(self) -> 'TLSKind': ...
    @property
    def extent(self) -> 'SourceRange': ...
    @property
    def storage_class(self) -> 'StorageClass': ...
    @property
    def availability(self) -> 'AvailabilityKind': ...
    @property
    def access_specifier(self) -> 'AccessSpecifier': ...
    @property
    def type(self) -> 'Type': ...
    @property
    def canonical(self) -> 'Cursor': ...
    @property
    def result_type(self) -> 'Type': ...
    @property
    def exception_specification_kind(self) -> 'ExceptionSpecificationKind': ...
    @property
    def underlying_typedef_type(self) -> 'Type': ...
    @property
    def enum_type(self) -> 'Type': ...
    @property
    def enum_value(self) -> int: ...
    @property
    def objc_type_encoding(self) -> str: ...
    @property
    def hash(self) -> int: ...
    @property
    def semantic_parent(self) -> typing.Optional['Cursor']: ...
    @property
    def lexical_parent(self) -> typing.Optional['Cursor']: ...
    @property
    def translation_unit(self) -> 'TranslationUnit': ...
    @property
    def referenced(self) -> 'Cursor': ...
    @property
    def brief_comment(self) -> typing.Optional[str]: ...
    @property
    def raw_comment(self) -> typing.Optional[str]: ...

    def get_arguments(self) -> typing.Iterator['Cursor']: ...
    def get_num_template_arguments(self) -> int: ...
    def get_template_argument_kind(self, num: int) -> 'TemplateArgumentKind': ...
    def get_template_argument_type(self, num: int) -> 'Type': ...
    def get_template_argument_value(self, num: int) -> int: ...
    def get_template_argument_unsigned_value(self, num: int) -> int: ...
    def get_children(self) -> typing.Iterator['Cursor']: ...
    def walk_preorder(self) -> typing.Iterator['Cursor']: ...
    def get_tokens(self) -> typing.Iterator['Token']: ...
    def get_field_offsetof(self) -> int: ...
    def get_bitfield_width(self) -> int: ...

    @staticmethod
    def from_result(res: 'Cursor', fn: typing.Any, args: typing.Sequence[typing.Any]) -> 'Cursor': ...


class StorageClass():
    def __init__(self, value: int) -> None: ...
    def from_param(self) -> int: ...
    @property
    def name(self) -> str: ...
    @staticmethod
    def from_id(id: int) -> 'StorageClass': ...

    {% for name in map(repr, cindex.StorageClass._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'StorageClass'
    {% endfor %}

class AvailabilityKind(BaseEnumeration):
    {% for name in map(repr, cindex.AvailabilityKind._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'AvailabilityKind'
    {% endfor %}

class AccessSpecifier(BaseEnumeration):
    {% for name in map(repr, cindex.AccessSpecifier._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'AccessSpecifier'
    {% endfor %}

class TypeKind(BaseEnumeration):
    @property
    def spelling(self) -> str: ...

    {% for name in cindex.TypeKind._kinds | not_none -%}
    {{str(name)[9:]}}: 'TypeKind'
    {% endfor %}

class RefQualifierKind(BaseEnumeration):
    {% for name in map(repr, cindex.RefQualifierKind._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'RefQualifierKind'
    {% endfor %}

class LinkageKind(BaseEnumeration):
    {% for name in map(repr, cindex.LinkageKind._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'LinkageKind'
    {% endfor %}

class TLSKind(BaseEnumeration):
    {% for name in map(repr, cindex.TLSKind._kinds) -%}
    {{name[name.rfind('.')+1:]}}: 'TLSKind'
    {% endfor %}

class Type(Structure):
    @property
    def kind(self) -> 'TypeKind': ...
    def argument_types(self) -> typing.Iterator['Type']: ...
    @property
    def element_type(self) -> 'Type': ...
    @property
    def element_count(self) -> int: ...
    @property
    def translation_unit(self) -> 'TranslationUnit': ...
    def get_num_template_arguments(self) -> int: ...
    def get_template_argument_type(self, num: int) -> 'Type': ...
    def get_canonical(self) -> 'Type': ...
    def is_const_qualified(self) -> bool: ...
    def is_volatile_qualified(self) -> bool: ...
    def is_restrict_qualified(self) -> bool: ...
    def is_function_variadic(self) -> bool: ...
    def get_address_space(self) -> int: ...
    def get_typedef_name(self) -> str: ...
    def is_pod(self) -> bool: ...
    def get_pointee(self) -> 'Type': ...
    def get_declaration(self) -> 'Cursor': ...
    def get_result(self) -> 'Type': ...
    def get_array_element_type(self) -> 'Type': ...
    def get_array_size(self) -> int: ...
    def get_class_type(self) -> 'Type': ...
    def get_named_type(self) -> 'Type': ...
    def get_align(self) -> int: ...
    def get_size(self) -> int: ...
    def get_offset(self, fieldname: str) -> int: ...
    def get_ref_qualifier(self) -> 'RefQualifierKind': ...
    def get_fields(self) -> typing.Iterator['Cursor']: ...
    def get_exception_specification_kind(self) -> 'ExceptionSpecificationKind': ...
    @property
    def spelling(self) -> str: ...

    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...


class ClangObject():
    def __init__(self, obj: typing.Any) -> None: ...
    def from_param(self) -> _CObjectPtr: ...


SpellingCache: typing.Dict[int, 'CompletionChunk']

class CompletionChunk():
    class Kind():
        def __init__(self, name: str) -> None: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...

    def __init__(self, completionString: str, key: int) -> None: ...
    def __repr__(self) -> str: ...

    @property
    def spelling(self) -> str: ...
    @property
    def kind(self) -> 'Kind': ...
    @property
    def string(self) -> str: ...

    def isKindOptional(self) -> bool: ...
    def isKindTypedText(self) -> bool: ...
    def isKindPlaceHolder(self) -> bool: ...
    def isKindInformative(self) -> bool: ...
    def isKindResultType(self) -> bool: ...

completionChunkKindMap: typing.Dict[int, CompletionChunk.Kind]


class CompletionString(ClangObject):
    class Availability():
        def __init__(self, name: str) -> None: ...
        def __str__(self) -> str: ...
        def __repr__(self) -> str: ...
        name: str

    def __len__(self) -> int: ...
    @property
    def num_chunks(self) -> int: ...
    def __getitem__(self, key: int) -> 'CompletionChunk': ...
    @property
    def priority(self) -> int: ...
    @property
    def availability(self) -> CompletionChunk.Kind: ...  # FIXME: This seems incorrect
    @property
    def briefComment(self) -> str: ...
    def __repr__(self) -> str: ...

availabilityKinds: typing.Dict[int, CompletionChunk.Kind]


class CodeCompletionResult(Structure):
    def __repr__(self) -> str: ...
    @property
    def kind(self) -> 'CursorKind': ...
    @property
    def string(self) -> CompletionString: ...


class CCRStructure(Structure):
    def __len__(self) -> int: ...
    def __getitem__(self, key: int) -> CodeCompletionResult: ...


class CodeCompletionResults(ClangObject):
    def __del__(self) -> None: ...
    @property
    def results(self) -> CCRStructure: ...
    @property
    def diagnostics(self) -> typing.Sequence['Diagnostic']: ...


class Index(ClangObject):
    @staticmethod
    def create(excludeDecls: bool = ...) -> 'Index': ...
    def __del__(self) -> None: ...
    def read(self, path: str) -> 'TranslationUnit': ...
    def parse(self,
              path: str,
              args: typing.Optional[typing.List[str]] = ...,
              unsaved_files: typing.Optional[typing.List[typing.Tuple[str, str]]] = ...,
              options: int = ...
              ) -> 'TranslationUnit': ...


class TranslationUnit(ClangObject):
    PARSE_NONE: int
    PARSE_DETAILED_PROCESSING_RECORD: int
    PARSE_INCOMPLETE: int
    PARSE_PRECOMPILED_PREAMBLE: int
    PARSE_CACHE_COMPLETION_RESULTS: int
    PARSE_SKIP_FUNCTION_BODIES: int
    PARSE_INCLUDE_BRIEF_COMMENTS_IN_CODE_COMPLETION: int

    @classmethod
    def from_source(cls,
                    filename: str,
                    args: typing.Optional[typing.List[str]] = ...,
                    unsaved_files: typing.Optional[typing.List[typing.Tuple[str, str]]] = ...,
                    options: int = ...,
                    index: typing.Optional['Index'] = ...
                    ) -> 'TranslationUnit': ...

    @classmethod
    def from_ast_file(cls, filename: str, index: typing.Optional['Index'] = ...) -> 'TranslationUnit': ...

    def __del__(self) -> None: ...
    @property
    def cursor(self) -> 'Cursor': ...
    @property
    def spelling(self) -> str: ...
    def get_includes(self) -> typing.Iterator['FileInclusion']: ...
    def get_file(self, filename: str) -> 'File': ...
    def get_location(self,
                     filename: str,
                     position: typing.Union[int, typing.Tuple[int, int]]
                     ) -> 'SourceLocation': ...
    def get_extent(self,
                   filename: str,
                   locations: typing.Union[typing.Tuple['SourceLocation', 'SourceLocation'],
                                           typing.Tuple[int, int],
                                           typing.Tuple[typing.Tuple[int, int], typing.Tuple[int, int]]]
                   ) -> 'SourceRange': ...
    @property
    def diagnostics(self) -> typing.Sequence['Diagnostic']: ...
    def reparse(self,
                unsaved_files: typing.Optional[typing.List[typing.Tuple[str, str]]] = ...,
                options: int = ...
                ) -> None: ...
    def save(self, filename: str) -> None: ...
    def codeComplete(self,
                     path: str,
                     line: int,
                     column: int,
                     unsaved_files: typing.Optional[typing.List[typing.Tuple[str, str]]] = ...,
                     include_macros: bool = ...,
                     include_code_patterns: bool = ...,
                     include_brief_comments: bool = ...
                     ) -> typing.Optional['CodeCompletionResults']: ...
    def get_tokens(self,
                   locations: typing.Optional[typing.Tuple['SourceLocation', 'SourceLocation']] = ...,
                   extent: typing.Optional['SourceRange'] = ...
                   ) -> typing.Iterator['Token']: ...


class File(ClangObject):
    @staticmethod
    def from_name(translation_unit: 'TranslationUnit', file_name: str) -> 'File': ...
    @property
    def name(self) -> str: ...
    @property
    def time(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class FileInclusion():
    def __init__(self, src: str, tgt: 'File', loc: 'SourceLocation', depth: int) -> None: ...

    source: str
    include: 'File'
    location: 'SourceLocation'
    depth: int
    @property
    def is_input_file(self) -> bool: ...


class CompilationDatabaseError(Exception):
    ERROR_UNKNOWN: int
    ERROR_CANNOTLOADDATABASE: int

    def __init__(self, enumeration: int, message: str) -> None: ...


class CompileCommand():
    @property
    def directory(self) -> str: ...
    @property
    def filename(self) -> str: ...
    @property
    def arguments(self) -> typing.Iterator[str]: ...


class CompileCommands():
    def __del__(self) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, i: int) -> 'CompileCommand': ...


class CompilationDatabase(ClangObject):
    def __del__(self) -> None: ...
    @staticmethod
    def fromDirectory(buildDir: str) -> 'CompilationDatabase': ...
    def getCompileCommands(self, filename: str) -> typing.Optional['CompileCommands']: ...
    def getAllCompileCommands(self) -> 'CompileCommands': ...


class Token(Structure):
    @property
    def spelling(self) -> str: ...
    @property
    def kind(self) -> 'TokenKind': ...
    @property
    def location(self) -> 'SourceLocation': ...
    @property
    def extent(self) -> 'SourceRange': ...
    @property
    def cursor(self) -> 'Cursor': ...


class Config():
    library_path: typing.Optional[str]
    library_file: typing.Optional[str]
    compatibility_check: bool
    loaded: bool

    @staticmethod
    def set_library_path(path: str) -> None: ...
    @staticmethod
    def set_library_file(filename: str) -> None: ...
    @staticmethod
    def set_compatibility_check(check_status: bool) -> None: ...
    @property
    def lib(self) -> CDLL: ...
    def get_filename(self) -> str: ...
    def get_cindex_library(self) -> CDLL: ...
    def function_exists(self, name: str) -> bool: ...
